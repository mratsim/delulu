// This file is @generated by prost-build.
/// -----------------------------------------------------------------------------
/// Airport - Simple nested message for IATA/ICAO codes
/// Used inside FlightData.from_flight and FlightData.to_flight
///
/// NOTE: Fields marked as optional in proto3 behave identically to required
/// for scalar/string/message types - they're always serializable.
/// The "optional" keyword primarily aids in code generation clarity and
/// distinguishing presence from default values.
/// -----------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Airport {
    /// Field 2: airport code as string
    #[prost(string, tag = "2")]
    pub airport: ::prost::alloc::string::String,
}
/// -----------------------------------------------------------------------------
/// FlightData - Core search parameters for a single leg
///
/// Optional markers indicate fields that may be omitted from encoding:
/// - max_stops: When omitted/absent → treat as unrestricted stops
/// - airlines: When empty → no airline filtering applied
/// - from_flight/to_flight: REQUIRED - searches won't work without airports
/// -----------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightData {
    /// REQUIRED: departure date (ISO 8601: "YYYY-MM-DD")
    #[prost(string, tag = "2")]
    pub date: ::prost::alloc::string::String,
    /// OPTIONAL: 0=none, 1=1 stop, 2=2 stops; omit for unrestricted
    #[prost(int32, optional, tag = "5")]
    pub max_stops: ::core::option::Option<i32>,
    /// OPTIONAL: airline carrier codes (AA, UA, DL...); empty = no filter
    #[prost(string, repeated, tag = "6")]
    pub airlines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// REQUIRED: origin airport
    #[prost(message, optional, tag = "13")]
    pub from_flight: ::core::option::Option<Airport>,
    /// REQUIRED: destination airport
    #[prost(message, optional, tag = "14")]
    pub to_flight: ::core::option::Option<Airport>,
}
/// -----------------------------------------------------------------------------
/// Info - Top-level container sent to Google Flights
/// Contains complete search configuration including multiple flight legs,
/// passenger breakdown, cabin class, and trip type.
///
/// All top-level fields in Info are effectively optional per Google Flights'
/// TFS protocol - the service fills reasonable defaults for anything omitted.
/// -----------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Info {
    /// Multiple FlightData for multi-leg/multi-city trips
    #[prost(message, repeated, tag = "3")]
    pub data: ::prost::alloc::vec::Vec<FlightData>,
    /// OPTIONAL: passenger mix; default assumed \[Adult x 1\]
    #[prost(enumeration = "Passenger", repeated, tag = "8")]
    pub passengers: ::prost::alloc::vec::Vec<i32>,
    /// OPTIONAL: cabin class; default economy
    #[prost(enumeration = "Seat", optional, tag = "9")]
    pub seat: ::core::option::Option<i32>,
    /// OPTIONAL: trip type; default round-trip
    #[prost(enumeration = "Trip", optional, tag = "19")]
    pub trip: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Seat {
    /// Unspecified (useful for some queries)
    UnknownSeat = 0,
    /// Standard economy
    Economy = 1,
    /// Premium economy
    PremiumEconomy = 2,
    /// Business class
    Business = 3,
    /// First class
    First = 4,
}
impl Seat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownSeat => "UNKNOWN_SEAT",
            Self::Economy => "ECONOMY",
            Self::PremiumEconomy => "PREMIUM_ECONOMY",
            Self::Business => "BUSINESS",
            Self::First => "FIRST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_SEAT" => Some(Self::UnknownSeat),
            "ECONOMY" => Some(Self::Economy),
            "PREMIUM_ECONOMY" => Some(Self::PremiumEconomy),
            "BUSINESS" => Some(Self::Business),
            "FIRST" => Some(Self::First),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Trip {
    /// Unspecified
    UnknownTrip = 0,
    /// Round trip booking
    RoundTrip = 1,
    /// One-way booking
    OneWay = 2,
    /// Multi-city/itinerary booking
    MultiCity = 3,
}
impl Trip {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownTrip => "UNKNOWN_TRIP",
            Self::RoundTrip => "ROUND_TRIP",
            Self::OneWay => "ONE_WAY",
            Self::MultiCity => "MULTI_CITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_TRIP" => Some(Self::UnknownTrip),
            "ROUND_TRIP" => Some(Self::RoundTrip),
            "ONE_WAY" => Some(Self::OneWay),
            "MULTI_CITY" => Some(Self::MultiCity),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Passenger {
    /// Unspecified passenger type
    UnknownPassenger = 0,
    /// Adult (ages 12+ typically)
    Adult = 1,
    /// Child (ages 2-12)
    Child = 2,
    /// Infant requiring own seat
    InfantInSeat = 3,
    /// Infant on lap (no seat assigned)
    InfantOnLap = 4,
}
impl Passenger {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownPassenger => "UNKNOWN_PASSENGER",
            Self::Adult => "ADULT",
            Self::Child => "CHILD",
            Self::InfantInSeat => "INFANT_IN_SEAT",
            Self::InfantOnLap => "INFANT_ON_LAP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_PASSENGER" => Some(Self::UnknownPassenger),
            "ADULT" => Some(Self::Adult),
            "CHILD" => Some(Self::Child),
            "INFANT_IN_SEAT" => Some(Self::InfantInSeat),
            "INFANT_ON_LAP" => Some(Self::InfantOnLap),
            _ => None,
        }
    }
}
